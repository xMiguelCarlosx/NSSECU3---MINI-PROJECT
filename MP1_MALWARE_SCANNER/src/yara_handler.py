"""
YARA rule handler with compilation and scanning.
Implements best practices from [citation:3][citation:7]
"""
import yara
import logging
from pathlib import Path
from typing import List, Dict, Optional

logger = logging.getLogger(__name__)

class YaraHandler:
    """Handle YARA rule compilation and scanning."""
    
    def __init__(self, rules_path: Path):
        """
        Initialize YARA handler with rules file.
        
        Args:
            rules_path: Path to .yar or .yara file
        """
        self.rules_path = Path(rules_path)
        self.rules = None
        self.compilation_errors = []
        self._compile_rules()
    
    def _compile_rules(self):
        """Compile YARA rules with error handling."""
        try:
            if not self.rules_path.exists():
                raise FileNotFoundError(f"Rules file not found: {self.rules_path}")
                
            self.rules = yara.compile(str(self.rules_path))
            logger.info(f"Successfully compiled rules from {self.rules_path}")
            
        except yara.SyntaxError as e:
            self.compilation_errors.append(f"Syntax error: {e}")
            logger.error(f"YARA syntax error: {e}")
            
        except yara.Error as e:
            self.compilation_errors.append(f"YARA error: {e}")
            logger.error(f"YARA compilation error: {e}")
    
    def scan_file(self, file_path: Path) -> Dict:
        """
        Scan a single file with loaded YARA rules.
        
        Args:
            file_path: Path to file to scan
            
        Returns:
            Dict with match results
        """
        if not self.rules:
            return {
                'matched': False,
                'rules': [],
                'error': 'Rules not compiled'
            }
            
        try:
            matches = self.rules.match(str(file_path))
            
            if matches:
                return {
                    'matched': True,
                    'rules': [match.rule for match in matches],
                    'meta': self._extract_meta(matches),
                    'count': len(matches)
                }
            else:
                return {
                    'matched': False,
                    'rules': [],
                    'count': 0
                }
                
        except Exception as e:
            logger.debug(f"Scan error {file_path}: {e}")
            return {
                'matched': False,
                'rules': [],
                'error': str(e)
            }
    
    @staticmethod
    def _extract_meta(matches):
        """Extract metadata from matches for reporting."""
        meta_list = []
        for match in matches:
            if hasattr(match, 'meta'):
                meta_list.append(match.meta)
        return meta_list