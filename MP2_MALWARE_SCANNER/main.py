#!/usr/bin/env python3
"""
MP2 Malware Scanner - Custom Byte-Based Scanner
No YARA library - uses direct byte pattern matching
"""
import argparse
import logging
import json
from pathlib import Path
from datetime import datetime
import sys

# Add src to path
sys.path.insert(0, str(Path(__file__).parent))

from src.scanner import MalwareScanner
from src.reporter import ScanReporter

# Simple color codes (no colorama needed)
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    CYAN = '\033[96m'
    RESET = '\033[0m'

def setup_logging(level=logging.INFO):
    """Configure logging for scanner."""
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('scanner.log'),
            logging.StreamHandler()
        ]
    )

def get_pattern_name_from_path(rules_path: Path) -> str:
    """
    Extract pattern name from rules file path.
    Examples:
        rules/ai_deepseek_patterns.txt -> deepseek
        rules/ai_chatgpt_patterns.txt -> chatgpt
        rules/ai_gemini_patterns.txt -> gemini
        rules/ai_copilot_patterns.txt -> copilot
        rules/ai_combined_patterns.txt -> combined
    """
    filename = rules_path.stem  # Gets filename without extension
    # Remove 'ai_' prefix and '_patterns' suffix
    pattern_name = filename.replace('ai_', '').replace('_patterns', '')
    return pattern_name

def main():
    parser = argparse.ArgumentParser(
        description='MP2 Malware Scanner - Custom Byte-Based Scanner',
        epilog='Mount disk with AIM first, then scan the mounted drive letter.'
    )
    
    parser.add_argument(
        'target',
        help='Path to scan (e.g., F:\\ or F:\\MP1_FILES)'
    )
    
    parser.add_argument(
        '--rules',
        default='rules/ai_combined_patterns.txt',
        help='Patterns file (default: rules/ai_combined_patterns.txt)'
    )
    
    parser.add_argument(
        '--quarantine',
        default='./quarantine',
        help='Quarantine directory (default: ./quarantine)'
    )
    
    parser.add_argument(
        '--output',
        help='Output report file (optional - auto-generated if not provided)'
    )
    
    parser.add_argument(
        '--threads',
        type=int,
        default=4,
        help='Number of scan threads (default: 4)'
    )
    
    parser.add_argument(
        '--quarantine-auto',
        action='store_true',
        help='Automatically quarantine detected malware'
    )
    
    parser.add_argument(
        '--log-level',
        default='INFO',
        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],
        help='Set logging level'
    )
    
    args = parser.parse_args()
    
    # Setup logging
    setup_logging(getattr(logging, args.log_level))
    
    # Validate target exists
    target_path = Path(args.target)
    if not target_path.exists():
        print(Colors.RED + f"‚ùå Error: Target path does not exist: {target_path}" + Colors.RESET)
        print("Did you mount the disk image with Arsenal Image Mounter?")
        return 1
    
    # Validate rules exist
    rules_path = Path(args.rules)
    if not rules_path.exists():
        print(Colors.RED + f"‚ùå Error: Patterns file not found: {rules_path}" + Colors.RESET)
        return 1
    
    # Get pattern name from rules file
    pattern_name = get_pattern_name_from_path(rules_path)
    
    # Generate output filename if not provided
    if not args.output:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        # Create filename like: scan_20260221_021954_deepseek.json
        filename = f"scan_{timestamp}_{pattern_name}.json"
        args.output = str(Path('reports') / filename)
    
    print(Colors.CYAN + "=" * 60)
    print(Colors.CYAN + "        MP2 MALWARE SCANNER - CUSTOM BYTE-BASED")
    print(Colors.CYAN + "=" * 60)
    print(f"Target:      {target_path}")
    print(f"Rules:       {rules_path}")
    print(f"Pattern:     {pattern_name}")
    print(f"Quarantine:  {args.quarantine}")
    print(f"Threads:     {args.threads}")
    print(f"Output:      {args.output}")
    print(Colors.CYAN + "-" * 60)
    
    # Initialize scanner
    scanner = MalwareScanner(
        rules_path=rules_path,
        quarantine_path=Path(args.quarantine),
        thread_count=args.threads
    )
    
    # Print pattern summary
    pattern_summary = scanner.rule_engine.get_pattern_summary()
    print(f"Loaded {pattern_summary['total_patterns']} patterns "
          f"({pattern_summary['patterns_by_type']['hex']} hex, "
          f"{pattern_summary['patterns_by_type']['string']} string)")
    
    # Run scan
    print(Colors.YELLOW + "\nüîç Scanning started..." + Colors.RESET)
    results = []
    
    try:
        for result in scanner.scan_directory(
            target_path,
            recursive=True,
            auto_quarantine=args.quarantine_auto
        ):
            results.append(result)
            
            # Live console output
            status = Colors.RED + "MALICIOUS" if result.get('is_malicious') else Colors.GREEN + "CLEAN"
            file_type = result.get('file_type', {}).get('description', 'Unknown')
            
            # Show matched patterns if malicious
            pattern_info = ""
            if result.get('is_malicious'):
                patterns = result.get('pattern_matches', {}).get('patterns', [])
                pattern_info = f" | Patterns: {len(patterns)}"
            
            print(f"[{status}{Colors.RESET}] {result['filename']:<15} | {file_type:<20} | "
                  f"MD5: {result.get('hashes',{}).get('md5','')[:8]}...{pattern_info}")
            
    except KeyboardInterrupt:
        print(Colors.YELLOW + "\n\n‚ö†Ô∏è Scan interrupted by user" + Colors.RESET)
    
    # Generate report
    print(Colors.CYAN + "\n" + "=" * 60)
    print("üìä SCAN COMPLETE")
    print("=" * 60)
    print(f"Files scanned:     {scanner.scan_stats['files_scanned']}")
    print(f"Malicious found:   {Colors.RED}{scanner.scan_stats['malicious_found']}{Colors.RESET}")
    print(f"Quarantined:       {scanner.scan_stats['quarantined']}")
    print(f"Errors:            {scanner.scan_stats['errors']}")
    print(f"Scan time:         {scanner.scan_stats['end_time'] - scanner.scan_stats['start_time']}")
    
    # Save report
    report_path = Path(args.output)
    report_path.parent.mkdir(exist_ok=True)
    
    # Prepare stats for JSON (convert datetime to string)
    stats_for_json = {
        'files_scanned': scanner.scan_stats['files_scanned'],
        'malicious_found': scanner.scan_stats['malicious_found'],
        'quarantined': scanner.scan_stats['quarantined'],
        'errors': scanner.scan_stats['errors'],
        'start_time': str(scanner.scan_stats['start_time']),
        'end_time': str(scanner.scan_stats['end_time'])
    }
    
    report_data = {
        'scan_metadata': {
            'target': str(target_path),
            'rules': str(rules_path),
            'pattern_name': pattern_name,
            'timestamp': datetime.now().isoformat(),
            'stats': stats_for_json,
            'pattern_summary': scanner.rule_engine.get_pattern_summary()
        },
        'results': results
    }
    
    with open(report_path, 'w') as f:
        json.dump(report_data, f, indent=2)
    
    print(Colors.GREEN + f"\n‚úÖ Report saved: {report_path}" + Colors.RESET)
    
    # Generate CSV with same pattern name
    csv_path = report_path.with_suffix('.csv')
    ScanReporter.save_csv(report_data, csv_path)
    print(Colors.GREEN + f"‚úÖ CSV saved: {csv_path}" + Colors.RESET)
    
    return 0

if __name__ == '__main__':
    exit(main())