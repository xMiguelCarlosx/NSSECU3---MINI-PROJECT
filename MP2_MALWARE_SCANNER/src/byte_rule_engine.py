"""
Byte Rule Engine for MP2
Replaces yara_handler.py - custom pattern matching without YARA
"""
import logging
from pathlib import Path
from typing import List, Dict, Optional
from .pattern_detector import PatternDetector

logger = logging.getLogger(__name__)

class ByteRuleEngine:
    """
    Custom rule engine that loads patterns from text files
    and performs byte-by-byte comparison.
    """
    
    def __init__(self, rules_path: Path):
        """
        Initialize with path to pattern text file.
        
        Args:
            rules_path: Path to .txt file containing patterns
        """
        self.rules_path = Path(rules_path)
        self.patterns = []
        self.load_errors = []
        self._load_patterns()
    
    def _load_patterns(self):
        """Load patterns from text file."""
        try:
            if not self.rules_path.exists():
                raise FileNotFoundError(f"Patterns file not found: {self.rules_path}")
                
            self.patterns = PatternDetector.load_patterns_from_file(self.rules_path)
            logger.info(f"Successfully loaded {len(self.patterns)} patterns from {self.rules_path}")
            
        except Exception as e:
            self.load_errors.append(str(e))
            logger.error(f"Error loading patterns: {e}")
    
    def scan_file(self, file_path: Path) -> Dict:
        """
        Scan a single file for pattern matches.
        
        Args:
            file_path: Path to file to scan
            
        Returns:
            Dict with match results
        """
        if not self.patterns:
            return {
                'matched': False,
                'patterns': [],
                'error': 'No patterns loaded'
            }
            
        try:
            matches = PatternDetector.scan_for_patterns(file_path, self.patterns)
            
            if matches:
                return {
                    'matched': True,
                    'patterns': matches,
                    'count': len(matches)
                }
            else:
                return {
                    'matched': False,
                    'patterns': [],
                    'count': 0
                }
                
        except Exception as e:
            logger.debug(f"Scan error {file_path}: {e}")
            return {
                'matched': False,
                'patterns': [],
                'error': str(e)
            }
    
    def get_pattern_summary(self) -> Dict:
        """Return summary of loaded patterns."""
        return {
            'total_patterns': len(self.patterns),
            'patterns_by_type': {
                'hex': len([p for p in self.patterns if p.get('hex_pattern')]),
                'string': len([p for p in self.patterns if p.get('string_pattern')])
            }
        }