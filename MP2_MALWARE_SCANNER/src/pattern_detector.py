"""
Byte Pattern Detector for MP2
Replaces magic_detector.py - No YARA, no magic modules
Detects file types and suspicious patterns using direct byte comparison
"""
import os
from pathlib import Path
from typing import Dict, List, Tuple, Optional

class PatternDetector:
    """
    Detects file types and suspicious patterns by reading file bytes
    and comparing against known patterns.
    """
    
    # File signatures (magic numbers) - direct byte comparison
    FILE_SIGNATURES = [
        # Format: (hex_pattern, extension, description)
        (b'\xFF\xD8\xFF', 'jpg', 'JPEG image'),
        (b'\x89PNG\r\n\x1A\n', 'png', 'PNG image'),
        (b'GIF87a', 'gif', 'GIF image'),
        (b'GIF89a', 'gif', 'GIF image'),
        (b'BM', 'bmp', 'BMP image'),
        (b'%PDF', 'pdf', 'PDF document'),
        (b'\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1', 'doc', 'MS Office OLE2'),
        (b'PK\x03\x04', 'docx', 'Office Open XML'),
        (b'MZ', 'exe', 'PE executable'),
        (b'\x7FELF', 'elf', 'ELF executable'),
        (b'Rar!\x1A\x07', 'rar', 'RAR archive'),
        (b'\x1F\x8B', 'gz', 'GZIP archive'),
        (b'7z\xBC\xAF\x27\x1C', '7z', '7-Zip archive'),
    ]
    
    @classmethod
    def load_patterns_from_file(cls, pattern_file: Path) -> List[Dict]:
        """
        Load patterns from AI-generated text file.
        Each pattern should be in format:
        PATTERN NAME: name
        DESCRIPTION: description
        OFFSET: offset or "anywhere"
        HEX PATTERN: hex bytes
        STRING PATTERN: text
        FILE TYPES: types
        """
        patterns = []
        if not pattern_file.exists():
            return patterns
            
        with open(pattern_file, 'r', encoding='utf-8') as f:
            content = f.read()
            
        # Parse pattern blocks
        blocks = content.split('PATTERN NAME:')
        for block in blocks[1:]:  # Skip first empty
            try:
                lines = block.strip().split('\n')
                pattern = {
                    'name': lines[0].strip(),
                    'description': '',
                    'offset': 'anywhere',
                    'hex_pattern': None,
                    'string_pattern': None,
                    'file_types': 'Any'
                }
                
                for line in lines[1:]:
                    if 'DESCRIPTION:' in line:
                        pattern['description'] = line.split('DESCRIPTION:')[1].strip()
                    elif 'OFFSET:' in line:
                        pattern['offset'] = line.split('OFFSET:')[1].strip()
                    elif 'HEX PATTERN:' in line:
                        hex_str = line.split('HEX PATTERN:')[1].strip()
                        # Convert hex string like "4D 5A" to bytes
                        hex_str = hex_str.replace(' ', '').replace('0x', '')
                        if hex_str:  # Only if not empty
                            pattern['hex_pattern'] = bytes.fromhex(hex_str)
                    elif 'STRING PATTERN:' in line:
                        str_val = line.split('STRING PATTERN:')[1].strip()
                        if str_val:
                            pattern['string_pattern'] = str_val.encode('utf-8')
                    elif 'FILE TYPES:' in line:
                        pattern['file_types'] = line.split('FILE TYPES:')[1].strip()
                
                patterns.append(pattern)
            except Exception as e:
                print(f"Error parsing pattern: {e}")
                
        return patterns
    
    @classmethod
    def detect_file_type(cls, file_path: Path) -> Dict[str, str]:
        """
        Detect file type by reading first bytes and comparing signatures.
        No magic modules - direct byte comparison.
        """
        try:
            with open(file_path, 'rb') as f:
                header = f.read(32)  # Read first 32 bytes
                
            # Check against file signatures
            for sig_bytes, ext, desc in cls.FILE_SIGNATURES:
                if header.startswith(sig_bytes):
                    return {
                        'extension': ext,
                        'description': desc,
                        'magic': sig_bytes.hex()[:16],
                        'confidence': 'HIGH'
                    }
            
            # Try ASCII text detection
            try:
                with open(file_path, 'r', encoding='ascii') as f:
                    f.read(100)
                return {
                    'extension': 'txt',
                    'description': 'ASCII text',
                    'magic': 'none',
                    'confidence': 'MEDIUM'
                }
            except UnicodeDecodeError:
                pass
                
            return {
                'extension': 'bin',
                'description': 'Binary data',
                'magic': header[:8].hex(),
                'confidence': 'LOW'
            }
            
        except Exception as e:
            return {
                'extension': 'unknown',
                'description': f'Error: {str(e)}',
                'magic': '',
                'confidence': 'NONE'
            }
    
    @classmethod
    def scan_for_patterns(cls, file_path: Path, patterns: List[Dict]) -> List[Dict]:
        """
        Scan file for suspicious byte patterns.
        Direct byte comparison - no YARA.
        """
        matches = []
        
        try:
            with open(file_path, 'rb') as f:
                file_content = f.read()
                
            for pattern in patterns:
                # Check hex pattern if exists
                if pattern.get('hex_pattern'):
                    if pattern['hex_pattern'] in file_content:
                        matches.append({
                            'pattern_name': pattern['name'],
                            'description': pattern['description'],
                            'type': 'hex'
                        })
                        continue  # Skip string check if hex matched
                
                # Check string pattern if exists
                if pattern.get('string_pattern'):
                    if pattern['string_pattern'] in file_content:
                        matches.append({
                            'pattern_name': pattern['name'],
                            'description': pattern['description'],
                            'type': 'string'
                        })
                        
        except Exception as e:
            print(f"Error scanning {file_path}: {e}")
            
        return matches