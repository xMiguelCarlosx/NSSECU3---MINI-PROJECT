"""
Core malware scanner engine for MP2.
No YARA - uses custom byte pattern matching.
"""
import logging
from pathlib import Path
from typing import Dict, List, Generator  # â† ADD THIS IMPORT
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime

from .pattern_detector import PatternDetector
from .hash_utils import HashCalculator
from .byte_rule_engine import ByteRuleEngine
from .quarantine import QuarantineManager

logger = logging.getLogger(__name__)

class MalwareScanner:
    """Main malware scanning engine."""
    
    def __init__(self, 
                 rules_path: Path,
                 quarantine_path: Path,
                 thread_count: int = 4):
        """
        Initialize scanner with components.
        
        Args:
            rules_path: Path to patterns text file
            quarantine_path: Path for quarantined files
            thread_count: Parallel scan threads
        """
        self.rule_engine = ByteRuleEngine(rules_path)
        self.quarantine = QuarantineManager(quarantine_path)
        self.thread_count = thread_count
        self.scan_stats = {
            'files_scanned': 0,
            'malicious_found': 0,
            'quarantined': 0,
            'errors': 0,
            'start_time': None,
            'end_time': None
        }
    
    def scan_file(self, file_path: Path, auto_quarantine: bool = False) -> Dict:
        """
        Comprehensive scan of single file.
        
        Returns dict with:
        - File info (name, path)
        - File type detection
        - MD5, SHA1, SHA256
        - Pattern match results
        - Quarantine status
        """
        result = {
            'filename': file_path.name,
            'path': str(file_path),
            'scan_time': datetime.now().isoformat()
        }
        
        try:
            # 1. File type detection (byte signatures)
            result['file_type'] = PatternDetector.detect_file_type(file_path)
            
            # 2. Hash calculation (MD5, SHA1, SHA256)
            result['hashes'] = HashCalculator.calculate(file_path)
            
            # 3. Pattern scanning (no YARA)
            result['pattern_matches'] = self.rule_engine.scan_file(file_path)
            
            # 4. Verdict and quarantine
            result['is_malicious'] = result['pattern_matches'].get('matched', False)
            
            if result['is_malicious'] and auto_quarantine:
                q_path = self.quarantine.quarantine_file(
                    file_path,
                    result['pattern_matches'].get('patterns', []),
                    result['hashes'].get('md5', 'unknown')
                )
                result['quarantine_path'] = str(q_path)
                self.scan_stats['quarantined'] += 1
                self.scan_stats['malicious_found'] += 1
            elif result['is_malicious']:
                self.scan_stats['malicious_found'] += 1
                
            self.scan_stats['files_scanned'] += 1
            
        except Exception as e:
            logger.error(f"Error scanning {file_path}: {e}")
            result['error'] = str(e)
            self.scan_stats['errors'] += 1
            
        return result
    
    def scan_directory(self, 
                      directory: Path, 
                      recursive: bool = True,
                      auto_quarantine: bool = False) -> Generator[Dict, None, None]:
        """
        Scan entire directory, yielding results per file.
        """
        self.scan_stats['start_time'] = datetime.now()
        
        # Collect all files
        if recursive:
            files = [p for p in Path(directory).rglob('*') if p.is_file()]
        else:
            files = [p for p in Path(directory).iterdir() if p.is_file()]
        
        # Parallel scan with ThreadPoolExecutor
        with ThreadPoolExecutor(max_workers=self.thread_count) as executor:
            future_to_file = {
                executor.submit(self.scan_file, f, auto_quarantine): f 
                for f in files
            }
            
            for future in as_completed(future_to_file):
                yield future.result()
        
        self.scan_stats['end_time'] = datetime.now()